# Digging Deeper

- [Scheduling Tasks](#scheduling-tasks)
    * [Scheduling](#scheduling)
        + [Scheduling Jobs](#scheduling-jobs)
    * [Schedule frequencies](#schedule-frequencies)
    * [Running the Scheduler](#running-the-scheduler)
- [Logging](#logging)
- [Thread](#thread)
- [Making HTTP Requests](#making-http-requests)
- [Plot: HTML DSL](#plot--html-dsl)
    * [Control Flow](#control-flow)
    * [HTMLView](#htmlview)
    * [Plot Docs](#plot-docs)
- [Serving Static Files](#serving-static-files)

## Scheduling Tasks

You'll likely want to run various recurring tasks associated with your server. In the past, this may have been done utilizing `cron`, but it can be frustrating to have your scheduling logic disconnected from your code.
To make this easy, Alchemy provides a clean API for scheduling repeated tasks & jobs.

### Scheduling

You can schedule recurring work for your application using the `schedule()` function. You'll probably want to do this in your `boot()` function. This returns a builder with which you can customize the frequency of the task.

```swift
struct ExampleApp: Application {
    func boot() {
        schedule { print("Good morning!") }
            .daily()
    }
}
```

#### Scheduling Jobs

You can also schedule jobs to be dispatched. Don't forget to run a worker to run the dispatched jobs.

```swift
app.schedule(job: BackupDatabase())
    .daily(hr: 23)
```

### Schedule frequencies

A variety of builder functions are offered to customize your schedule frequency. If your desired frequency is complex, you can even schedule a task using a cron expression.

```swift
// Every week on tuesday at 8:00 pm
app.schedule { ... }
    .weekly(day: .tue, hr: 20)

// Every second
app.schedule { ... }
    .secondly()

// Every minute at 30 seconds
app.schedule { ... }
    .minutely(sec: 30)

// At 22:00 on every day-of-week from Monday through Friday.”
app.schedule { ... }
    .cron("0 22 * * 1-5")
```

### Running the Scheduler

Note that by default, your app won't actually schedule tasks. You'll need to pass the `--schedule` flag to either the `serve` (default) or `queue` command.

```bash
# Serves and schedules
swift run MyServer --schedule

# Runs a queue worker and schedules
swift run MyServer queue --schedule
```

## Logging

To aid with logging, Alchemy provides a lightweight wrapper on top of [SwiftLog](https://github.com/apple/swift-log).

You can conveniently log to the various levels via static functions on the `Log` struct.

```swift
Log.trace("Here")
Log.debug("Testing")
Log.info("Hello")
Log.notice("FYI")
Log.warning("Hmmm")
Log.error("Uh oh")
Log.critical("Houston, we have a problem")
```

These log to `Log.logger`, an instance of `SwiftLog.Logger`, which defaults to a basic stdout logger. This is a settable variable so you may overwrite it to be a more complex `Logger`. See [SwiftLog](https://github.com/apple/swift-log) for advanced usage.

## Thread

As mentioned in [Under the Hood](12_UnderTheHood.md), you'll want to avoid blocking the current `EventLoop` as much as possible to help your server have maximum request throughput.

Should you need to do some blocking work, such as file IO or CPU intensive work, `Thread` provides a dead simple interface for running work on a separate (non-`EventLoop`) thread. 

Initiate work with `Thread.run` which takes a closure, runs it on a separate thread, and returns the value generated by the closure back on the initiating `EventLoop`.

```swift
Thread
    .run { 
        // Will be run on a separate thread.
        blockingWork() 
    }
    .whenSuccess { value in
        // Back on the initiating `EventLoop`, with access to any value 
        // returned by `blockingWork()`.
    }
```

## Making HTTP Requests

HTTP requests should be made with [AsyncHTTPClient](https://github.com/swift-server/async-http-client). For convenience `HTTPClient` is a `Service` and a default one is registered to your application container.

```swift
HTTPClient.default
    .get(url: "https://swift.org")
    .whenComplete { result in
        switch result {
        case .failure(let error):
            ...
        case .success(let response):
            ...
        }
    }
```

## Plot: HTML DSL

Out of the box, Alchemy supports [Plot](https://github.com/JohnSundell/Plot), a Swift DSL for writing type safe HTML. With Plot, returning HTML is dead simple and elegant. You can do so straight from a `Router` handler.

```swift
app.get("/website") { _ in
    return HTML {
        .head(
            .title("My website"),
            .stylesheet("styles.css")
        ),
        .body(
            .div(
                .h1(.class("title"), "My website"),
                .p("Writing HTML in Swift is pretty great!")
            )
        )
    }
}
```

### Control Flow

Plot also supports inline control flow with conditionals, loops, and even unwrapping. It's the perfect, type safe substitute for a templating language.

```swift
let animals: [String] = ...
let showSubtitle: Bool = ...
let username: String? = ...
HTML {
    .head(
        .title("My website"),
        .stylesheet("styles.css")
    ),
    .body(
        .div(
            .h1("My favorite animals are..."),
            .if(showSubtitle, 
                .h2("You found the subtitle")
            ),
            .ul(.forEach(animals) {
                .li(.class("name"), .text($0))
            }),
            .unwrap(username) {
                .p("Hello, \(username)")
            }
        )
    )
}
```

### HTMLView

You can use the `HTMLView` type to help organize your projects view and pages. It is a simple protocol with a single requirement, `var content: HTML`. Like `HTML`, `HTMLView`s can be returned directly from a `Router` handler.

```swift
struct HomeView: HTMLView {
    let showSubtitle: Bool
    let animals: [String]
    let username: String?

    var content: HTML {
        HTML {
            .head(
                .title("My website"),
                .stylesheet("styles.css")
            ),
            .body(
                .div(
                    .h1("My favorite animals are..."),
                    .if(self.showSubtitle, 
                        .h2("You found the subtitle")
                    ),
                    .ul(.forEach(self.animals) {
                        .li(.class("name"), .text($0))
                    }),
                    .unwrap(self.username) {
                        .p("Hello, \(username)")
                    }
                )
            )
        }
    }
}

app.get("/home") { _ in
    HomeView(showSubtitle: true, animals: ["Orangutan", "Axolotl", "Echidna"], username: "Kendra")
}
```

### Plot Docs

Check out the [Plot docs](https://github.com/JohnSundell/Plot) for everything you can do with it.

## Serving Static Files

If you'd like to serve files from a static directory, there's a `Middleware` for that. It will match incoming requests to files in the directory, streaming those back to the client if they exist. By default, it serves from `Public/` but you may pass a custom path in the initializer if you like. 

Consider a `Public` directory in your project with a few files.

```
│
├── Public
│   ├── css
│   │   └── style.css
│   ├── js
│   │   └── app.js
│   ├── images
│   │   └── puppy.png
│   └── index.html
│
├── Sources
├── Tests
└── Package.swift
```

You could use the following code to serve files from that directory.

```swift
app.useAll(StaticFileMiddleware())
```

Now, assets in the `Public/` directory can be requested.
``` 
http://localhost:3000/index.html
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/puppy.png
http://localhost:3000/ (by default, will return any `index.html` file)
```

**Note**: The given directory is relative to your server's working directory. If you are using Xcode, be sure to [set a custom working directory](1_Configuration.md#setting-a-custom-working-directory) for your project where the static file directory is.

_Next page: [Deploying](11_Deploying.md)_

_[Table of Contents](/Docs#docs)_
