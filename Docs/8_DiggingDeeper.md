# Digging Deeper

- [Scheduled Jobs](#scheduled-jobs)
  * [Creating a job](#creating-a-job)
  * [Scheduling](#scheduling)
  * [Schedule frequencies](#schedule-frequencies)
- [Logging](#logging)
- [Thread](#thread)
- [Making HTTP Requests](#making-http-requests)
- [Plot: HTML DSL](#plot-html-dsl)
  * [Control Flow](#control-flow)
  * [HTMLView](#htmlview)
  * [Plot Docs](#plot-docs)
- [Serving Static Files](#serving-static-files)

## Scheduled Jobs

`Scheduler` provides an API for cron-like scheduling.

### Creating a job

Jobs must conform to the `Job` protocol. It has a single function `func run() -> EventLoopFuture<Void>` which performs the work to be scheduled.

```swift
struct BackupDatabase: Job {
    func run() -> EventLoopFuture<Void> {
        ...
    }
}
```

### Scheduling

Often backend services need to schedule recurring work such as running various database queries or pulling from external endpoints.

To do this, use `Scheduler`. It is automatically registered in Container.global & will likely be setup in your `Application.setup`.

```swift
struct ExampleApp: Application {
    @Inject var scheduler: Scheduler
    ...

    func setup() {
        ...
        self.scheduler
            // The scheduler will fire the `run` function on the BackupDatabase
            // job every day @ 12am.
            .every(1.days.at(hr: 0, min: 0), run: BackupDatabase())
    }
}
```

### Schedule frequencies

To aid in fine tuning when your scheduled `Job`s run, Alchemy provides some extensions on `Int` to pass to the `every` parameter.

Note that calls to `every(_:run:)` can be chained for readability.

```swift
scheduler
    // Runs every day starting when the server is launched.
    .every(1.days, run: BackupDatabase())
    // Runs every day @ 9:30am.
    .every(1.days.at(hr: 9, min: 30), run: EmailNewUsers())
    // Runs every hour @ X:00:00.
    .every(1.hour.at(min: 00, sec: 00), run: SlackAPIStatus())
    // Runs every minute @ X:XX:30.
    .every(1.minutes.at(sec: 30), run: CheckAPIStatus())
```

## Logging

To aid with logging, Alchemy provides a thin wrapper on top of [SwiftLog](https://github.com/apple/swift-log).

You can conveniently log to the various levels via static functions on the `Log` struct.

```swift
Log.trace("Here")
Log.debug("Testing")
Log.info("Hello")
Log.notice("FYI")
Log.warning("Hmmm")
Log.error("Uh oh")
Log.critical("Houston, we have a problem")
```

These log to `Log.logger`, an instance of `SwiftLog.Logger`, which defaults to a basic stdout logger. This is a settable variable so you may overwrite it to be a more complex `Logger`. See [SwiftLog](https://github.com/apple/swift-log) for advanced usage.

## Thread

As mentioned in [Architecture](1a_Architecture.md), you want to avoid blocking the current `EventLoop` as much as possible to help your server have maximum request throughput.

Should you need to do some blocking work, such as file IO or CPU intensive work, `Thread` provides a dead simple interface for running work on a separate (non-`EventLoop`) thread. 

Initiate work with `Thread.run` which takes a closure, runs it on a separate thread, and returns the value generated by the closure back on the initiating `EventLoop`.

```swift
Thread
    .run { 
        // Will be run on a separate thread.
        self.blockingWork() 
    }
    .whenSuccess { value in
        // Back on the initiating `EventLoop`, with access to any value 
        // returned by `self.blockingWork()`.
    }
```

## Making HTTP Requests

HTTP requests should be made with [AsyncHTTPClient](https://github.com/swift-server/async-http-client). For convenience, an `HTTPClient` configured with the applications `EventLoopGroup` is available for usage via `Services.client`.

```swift
Services.client
    .get(url: "https://swift.org")
    .whenComplete { result in
        switch result {
        case .failure(let error):
            ...
        case .success(let response):
            ...
        }
    }
```

## Plot: HTML DSL

Out of the box, Alchemy supports [Plot](https://github.com/JohnSundell/Plot), a Swift DSL for writing type safe HTML. With Plot, returning HTML is dead simple and elegant. You can do so straight from a `Router` handler.

```swift
self.router.on(.GET) {
    HTML {
        .head(
            .title("My website"),
            .stylesheet("styles.css")
        ),
        .body(
            .div(
                .h1(.class("title"), "My website"),
                .p("Writing HTML in Swift is pretty great!")
            )
        )
    }
}
```

### Control Flow

Plot also supports inline control flow with conditionals, loops, and even unwrapping. It's the perfect, type safe substitute for a templating language.

```swift
let animals: [String] = ...
let showSubtitle: Bool = ...
let username: String? = ...
HTML {
    .head(
        .title("My website"),
        .stylesheet("styles.css")
    ),
    .body(
        .div(
            .h1("My favorite animals are..."),
            .if(showSubtitle, 
                .h2("You found the subtitle")
            ),
            .ul(.forEach(animals) {
                .li(.class("name"), .text($0))
            }),
            .unwrap(username) {
                .p("Hello, \(username)")
            }
        )
    )
}
```

### HTMLView

You can use the `HTMLView` type to help organizing your projects view and pages. It is a simple protocol with a single requirement, `var content: HTML`. Like `HTML`, `HTMLView`s can be returned directly from a `Router` handler.

```swift
struct HomeView: HTMLView {
    let showSubtitle: Bool
    let animals: [String]
    let username: String?

    var content: HTML {
        HTML {
            .head(
                .title("My website"),
                .stylesheet("styles.css")
            ),
            .body(
                .div(
                    .h1("My favorite animals are..."),
                    .if(self.showSubtitle, 
                        .h2("You found the subtitle")
                    ),
                    .ul(.forEach(self.animals) {
                        .li(.class("name"), .text($0))
                    }),
                    .unwrap(self.username) {
                        .p("Hello, \(username)")
                    }
                )
            )
        }
    }
}

router.on(.GET) { _ in
    HomeView(showSubtitle: true, animals: ["Orangutan", "Axolotl", "Echidna"], username: "Kendra")
}
```

### Plot Docs

Check out the [Plot docs](https://github.com/JohnSundell/Plot) for everything you can do with it.

## Serving Static Files

If you'd like to serve files from a static directory, there's a `Middleware` for that. It will match incoming requests to files in the directory, streaming those back to the client if they exist. By default, it serves from `Public/` but you may pass a custom path in the initializer if you like. 

Consider a `Public` directory in your project with a few files.

```
│
├── Public
│   ├── css
│   │   └── style.css
│   ├── js
│   │   └── app.js
│   ├── images
│   │   └── puppy.png
│   └── index.html
│
├── Sources
├── Tests
└── Package.swift
```

You could use the following code to serve files from that directory.

```swift
router.globalMiddlewares = [
    StaticFileMiddleware()
]
```

Now, assets in the `Public/` directory can be requested.
``` 
http://localhost:8888/index.html
http://localhost:8888/css/style.css
http://localhost:8888/js/app.js
http://localhost:8888/images/puppy.png
http://localhost:8888/ (by default, will return any `index.html` file)
```

**Note**: The given directory is relative to your server's working directory. If you are using Xcode, be sure to set a custom working directory to your project where the static file directory is.

_[Table of Contents](/Docs#docs)_
