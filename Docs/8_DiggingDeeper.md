# Digging Deeper

## Scheduled Jobs

`Scheduler` provides an API for cron-like scheduling.

### Creating a job

Jobs must conform to the `Job` protocol. It has a single function `func run() -> EventLoopFuture<Void>` which performs the work to be scheduled.

```swift
struct BackupDatabase: Job {
    func run() -> EventLoopFuture<Void> {
        ...
    }
}
```

### Scheduling

Often backend services need to schedule recurring work such as running various database queries or pulling from external endpoints.

To do this, use `Scheduler`. It is automatically registered in Container.global & will likely be setup in your `Application.setup`.

```swift
struct ExampleApp: Application {
    @Inject var scheduler: Scheduler
    ...

    func setup() {
        ...
        self.scheduler
            // The scheduler will fire the `run` function on the BackupDatabase
            // job every day @ 12am.
            .schedule(BackupDatabase(), every: 1.days)
    }
}
```

### Schedule frequencies

To aid in fine tuning when your scheduled `Job`s run, Alchemy provides some extensions on `Int` to pass to the `every` parameter.

Note that calls to `scheduele` can be chained for readability.

```swift
scheduler
    // Runs every day @ midnight.
    .schedule(BackupDatabase(), every: 1.days)
    // Runs every day @ 9:30am.
    .schedule(EmailNewUsers(), every: 1.days.at(hr: 9, min: 30))
    // Runs every hour @ X:00:00.
    .schedule(SlackAPIStatus(), every: 1.hour)
    // Runs every minute @ X:XX:30.
    .schedule(CheckAPIStatus(), every: 1.minutes.at(sec: 30))
```

## Logging

To aid with logging, Alchemy provides a thin wrapper on top of [SwiftLog](https://github.com/apple/swift-log).

You can conveniently log to the various levels via static functions on the `Log` struct.

```swift
Log.trace("Here")
Log.debug("Testing")
Log.info("Hello")
Log.notice("FYI")
Log.warning("Hmmm")
Log.error("Uh oh")
Log.critical("Houston, we have a problem")
```

These log to `Log.logger`, an instance of `SwiftLog.Logger`, which defaults to a basic stdout logger. This is a settable variable so you may overwrite it to be a more complex `Logger`. See [SwiftLog](https://github.com/apple/swift-log) for advanced usage.

## Thread

As mentioned in [Architecture](Docs/1a_Architecture.md), you want to avoid blocking the current `EventLoop` as much as possible to help your server have maximum request throughput.

Should you need to do some blocking work, such as file IO or CPU intensive work, `Thread` provides a dead simple interface for running work on a separate (non-`EventLoop`) thread. 

Initiate work with `Thread.run` which takes a closure, runs it on a separate thread, and returns the value generated by the closure back on the initiating `EventLoop`.

```swift
Thread
    .run { 
        // Will be run on a separate thread.
        self.blockingWork() 
    }
    .whenSuccess { value in
        // Back on the initiating `EventLoop`, with access to any value 
        // returned by `self.blockingWork()`.
    }
```

## Making HTTP Requests

HTTP requests should be made with [AsyncHTTPClient](https://github.com/swift-server/async-http-client). For convenience, an `HTTPClient` configured with the applications `EventLoopGroup` is available for usage via `Global.httpClient`.

```swift
Global.httpClient
    .get(url: "https://swift.org")
    .whenComplete { result in
        switch result {
        case .failure(let error):
            ...
        case .success(let response):
            ...
        }
    }
```

_[Table of Contents](/Docs)_